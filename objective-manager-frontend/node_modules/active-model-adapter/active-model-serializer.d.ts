import RESTSerializer from '@ember-data/serializer/rest';
import type Store from '@ember-data/store';
import type Model from '@ember-data/model';
import { AnyObject } from 'active-model-adapter';
import DS from 'ember-data';
import type ModelRegistry from 'ember-data/types/registries/model';
declare type ModelKeys<K> = Exclude<keyof K, keyof DS.Model>;
declare type RelationshipsFor<K extends keyof ModelRegistry> = ModelKeys<ModelRegistry[K]>;
interface RelationshipMetaOptions {
    async?: boolean;
    inverse?: string;
    polymorphic?: boolean;
    [k: string]: unknown;
}
interface RelationshipMeta<K extends keyof ModelRegistry> {
    key: RelationshipsFor<K>;
    kind: 'belongsTo' | 'hasMany';
    type: keyof ModelRegistry;
    options: RelationshipMetaOptions;
    name: RelationshipsFor<K>;
    isRelationship: true;
}
interface Payload {
    [key: string]: unknown;
}
/**
  @module ember-data
 */
declare type RelationshipKind = 'belongsTo' | 'hasMany';
/**
  The ActiveModelSerializer is a subclass of the RESTSerializer designed to integrate
  with a JSON API that uses an underscored naming convention instead of camelCasing.
  It has been designed to work out of the box with the
  [active\_model\_serializers](http://github.com/rails-api/active_model_serializers)
  Ruby gem. This Serializer expects specific settings using ActiveModel::Serializers,
  `embed :ids, embed_in_root: true` which sideloads the records.

  This serializer extends the DS.RESTSerializer by making consistent
  use of the camelization, decamelization and pluralization methods to
  normalize the serialized JSON into a format that is compatible with
  a conventional Rails backend and Ember Data.

  ## JSON Structure

  The ActiveModelSerializer expects the JSON returned from your server
  to follow the REST adapter conventions substituting underscored keys
  for camelcased ones.

  ### Conventional Names

  Attribute names in your JSON payload should be the underscored versions of
  the attributes in your Ember.js models.

  For example, if you have a `Person` model:

  ```javascript
  export default class Person extends Model {
    @attr() firstName;
    @attr() lastName;
    @belongsTo('occupation') occupation;
  }
  ```

  The JSON returned should look like this:

  ```json
  {
    "famous_person": {
      "id": 1,
      "first_name": "Barack",
      "last_name": "Obama",
      "occupation": "President"
    }
  }
  ```

  Let's imagine that `Occupation` is just another model:

  ```javascript
  export default class Person extends Model {
    @attr() firstName;
    @attr() lastName;
    @belongsTo('occupation') occupation;
  }

  export default class Occupation extends Model {
    @attr() name;
    @attr('number') salary;
    @hasMany('person') people;
  }
  ```

  The JSON needed to avoid extra server calls, should look like this:

  ```json
  {
    "people": [{
      "id": 1,
      "first_name": "Barack",
      "last_name": "Obama",
      "occupation_id": 1
    }],

    "occupations": [{
      "id": 1,
      "name": "President",
      "salary": 100000,
      "person_ids": [1]
    }]
  }
  ```
*/
export default class ActiveModelSerializer extends RESTSerializer {
    store: Store;
    /**
      Converts camelCased attributes to underscored when serializing.
    */
    keyForAttribute(attr: string): string;
    /**
      Underscores relationship names and appends "_id" or "_ids" when serializing
      relationship keys.
    */
    keyForRelationship(relationshipModelName: string, kind?: string): string;
    /**
     `keyForLink` can be used to define a custom key when deserializing link
     properties. The `ActiveModelSerializer` camelizes link keys by default.
  
    */
    keyForLink(key: string, _relationshipKind: RelationshipKind): string;
    serializeHasMany(): void;
    /**
     Underscores the JSON root keys when serializing.
    */
    payloadKeyFromModelName(modelName: string | number): string;
    /**
      Serializes a polymorphic type as a fully capitalized model name.
    */
    serializePolymorphicType<K extends keyof ModelRegistry>(snapshot: DS.Snapshot<K>, json: Payload, relationship: RelationshipMeta<K>): void;
    /**
      Add extra step to `DS.RESTSerializer.normalize` so links are normalized.
  
      If your payload looks like:
  
      ```json
      {
        "post": {
          "id": 1,
          "title": "Rails is omakase",
          "links": { "flagged_comments": "api/comments/flagged" }
        }
      }
      ```
  
      The normalized version would look like this
  
      ```json
      {
        "post": {
          "id": 1,
          "title": "Rails is omakase",
          "links": { "flaggedComments": "api/comments/flagged" }
        }
      }
      ```
    */
    normalize(typeClass: Model, hash: AnyObject, prop: string): AnyObject;
    /**
      Convert `snake_cased` links  to `camelCase`
    */
    normalizeLinks(data: any): void;
    /**
     * @private
     */
    _keyForIDLessRelationship(key: string, relationshipType: RelationshipKind): string;
    extractRelationships(modelClass: Model, resourceHash: AnyObject): AnyObject;
    modelNameFromPayloadKey<K extends keyof ModelRegistry>(key: K): string;
}
export {};
